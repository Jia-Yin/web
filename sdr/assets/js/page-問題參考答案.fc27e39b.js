(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{674:function(t,s,l){"use strict";l.r(s);var o=l(1),i=Object(o.a)({},(function(){var t=this,s=t.$createElement,l=t._self._c||s;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"問題參考答案"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#問題參考答案"}},[t._v("#")]),t._v(" 問題參考答案")]),t._v(" "),l("ol",[l("li",[t._v("如果不接 Throttle 的話有何影響？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("使用 htop 觀察，可以看到，如果把 Throttle 拿掉，模擬程式幾乎耗掉系統大部份的 CPU 資源。但接上 Throttle 之後，系統所耗用的資源相對減少很多。")]),t._v(" "),l("p",[t._v("GNU Radio 在進行系統模擬時，可以看成是資料驅動的方式，也就是說，對於一個模組來說，一旦有資料進來，就必須立刻進行處理，而處理完之後，又會發送給後面的模組。那麼在系統模擬的過程中，如果有一些元件與硬體相關，例如喇叭模組、軟體無線電發送與接收模組，當存在這些模組時，由於會牽涉到硬體，而硬體本身對於資料的處理速度有所限制，因此系統的模擬速度也會跟著做調整。")]),t._v(" "),l("p",[t._v("在這個實驗中，除掉 Throttle 模組，由於不存在任何硬體相關的模組，因此系統會以最快的速度進行模擬，因此會耗掉系統大部份的資源。而 Throttle 模組，實際上是用來限制資料處理速度的模組，其每秒的處理速度，由其中的 Sample Rate 參數決定。加上這個模組之後，系統的模擬速度減緩很多，因此耗掉的 CPU 資源也會大幅下降。")])]),t._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[t._v("QT GUI Frequency Sink 是否正確反應訊號頻率？如果訊號源的抽樣率與 Frequency Sink 設定的 bandwidth 不同的話，會有何影響？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("如果 Frequency Sink 設定的 bandwidth 與 samp_rate 相同，則可以反應出正確的訊號頻率。如果設定不同的話，會發現示波器的圖形基本上一樣，但是頻率的刻度會改變。")]),t._v(" "),l("p",[t._v("實際上，Frequency Sink 所收到的資料內容都是一樣的，我們無法單獨由這些資料內容判定實際的頻率值。例如，在前面的抽樣模擬實驗中，當我們把轉速及抽樣速率增加同樣倍數時，圓周的抽樣點其實是一樣的，因此無法單獨由圓周的抽樣點來決定實際的轉速。要決定實際的轉速，必須加上每秒所抽樣的速率才能決定。此處 Frequency Sink 也是同樣的道理。當我們把 bandwidth 減成一半時，看到的頻率值也會變成一半。")])]),t._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[t._v("如果改變訊號源的頻率的話 (0~16K), Frequency Sink 的圖形會有何改變？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("所看到的訊號頻率，會從示波器的中心點，一直向右移到最右邊的邊界。")])]),t._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[t._v("如果改變訊號源的頻率的話 (>16K), Frequency Sink 的圖形會有何改變？為什麼有這些改變？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("超過 16K 之後，所看到的訊號頻率，會從示波器的最右邊的邊界跳回到最左邊的邊界，接下來再往右移動。")]),t._v(" "),l("p",[t._v("超過 16K 之後，其訊號頻率與負的頻率成份實際上是無法區分的，例如對於抽樣速率 32K 而言，20K 的頻率訊號與 -12K 的頻率訊號其實抽樣值都是一樣的。示波器會以最小的正負範圍做為判斷的標準，因此超過 16K，就會轉回到負值的部份。")])]),t._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[t._v("如果訊號源的頻率變成負值呢？( cos(x) vs. cos(-x) ? )")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("如果把頻率設成負值，訊號的頻率會出現在中心點左邊，當負值變大時，訊號會往左移動。")])]),t._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[t._v("Frequency Sink 除了訊號源的頻率之外，可否觀察到其他頻率訊號存在？請說明為何會出現雜訊之類的訊號？雜訊大小如何？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("可以看到有許多雜訊的訊號存在。會出現這些雜訊，主要是因為 rounding error，也就是計算機在處理浮點數字時所產生的誤差。使用越多位元，可以讓雜訊變得更小。")])]),t._v(" "),l("ol",{attrs:{start:"7"}},[l("li",[t._v("試著增加訊號源數量，會發生什麼狀況呢？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("會看到更多的頻率成份，兩者之間的頻率成份也會略微增加。")])]),t._v(" "),l("ol",{attrs:{start:"8"}},[l("li",[t._v("訊號源預設的輸出形式為 Consine，試著改變訊號源的輸出形式，會發生什麼狀況呢？")])]),t._v(" "),l("div",{staticClass:"custom-block info"},[l("p",{staticClass:"custom-block-title"},[t._v("Answer")]),t._v(" "),l("p",[t._v("會看到示波器上面，出現許多等間隔的諧波成份。")])])])}),[],!1,null,null,null);s.default=i.exports}}]);