(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{581:function(t,i,v){t.exports=v.p+"assets/img/2021-04-23-22-42-54.62738ec0.png"},582:function(t,i,v){t.exports=v.p+"assets/img/2021-04-23-23-03-12.a7162414.png"},583:function(t,i,v){t.exports=v.p+"assets/img/2021-04-23-22-43-35.3c4629f1.png"},708:function(t,i,v){"use strict";v.r(i);var _=v(1),s=Object(_.a)({},(function(){var t=this,i=t.$createElement,_=t._self._c||i;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"使用網路傳送音頻"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用網路傳送音頻"}},[t._v("#")]),t._v(" 使用網路傳送音頻")]),t._v(" "),_("p",[t._v("這個小單元要利用網路來傳送音頻資料。一般網路傳送資料多使用 TCP 或 UDP，TCP 本身具有傳輸錯誤控制的能力，如果接收到的封包偵測到錯誤，會請傳送端重傳，因此可以保證傳輸資料的正確性。UDP 本身則不具傳輸錯誤控制的能力，因此傳送資料時，可能較 TCP 來得快速，但不保證所傳的資料都是正確的。由於 TCP 傳送時，如果資料重傳，將會增加封包傳送的延遲時間，這對於即時的語音或影像的通訊來說並不適合，因此大多數語音或影像的通訊，除了控制部份採用 TCP 之外，大部份資料的傳送，則是採用 UDP 來進行傳送。")]),t._v(" "),_("p",[t._v("本單元主要利用 GNU Radio 來示範網路資料的傳送，將忽略 TCP 控制的部份，只使用 UDP 來傳送及接收資料。")]),t._v(" "),_("h2",{attrs:{id:"傳送端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#傳送端"}},[t._v("#")]),t._v(" 傳送端")]),t._v(" "),_("p",[t._v("從程式庫模組中選擇 Signal Source, Throttle, QT GUI Time Sink, 及 UDP Sink 模組。將四個模組如下圖方式連接在一起：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(581),alt:""}})]),t._v(" "),_("p",[t._v("這邊四個模組的參數依次如下：")]),t._v(" "),_("ul",[_("li",[t._v("Signal Source: 把 Output Type 改成 float。")]),t._v(" "),_("li",[t._v("Throttle: 全部用預設值。")]),t._v(" "),_("li",[t._v("QT GUI Sink: 全部用預設值。")]),t._v(" "),_("li",[t._v("UDP Sink: 只改以下兩個參數\n"),_("ul",[_("li",[t._v("Destination IP Address 改成 127.0.0.1，代表本機")]),t._v(" "),_("li",[t._v("Destination Port 改成 12345")])])])]),t._v(" "),_("p",[t._v("注意 UDP Sink 的參數，表示資料將會傳送到本機的 UDP Port 12345。另外我們額外接一個 QT GUI Sink，主要是用來觀察傳送的訊號。")]),t._v(" "),_("p",[t._v("接好之後，將檔案存檔，產出模型並執行，應該會看到輸出的弦波圖形，如下圖所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(582),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"接收端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接收端"}},[t._v("#")]),t._v(" 接收端")]),t._v(" "),_("p",[t._v("從程式庫模組中選擇 UDP Source, QT GUI Time Sink, 及 Audio Sink 模組。將三個模組如下圖方式連接在一起：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(583),alt:""}})]),t._v(" "),_("p",[t._v("這邊三個模組的參數依次如下：")]),t._v(" "),_("ul",[_("li",[t._v("UDP Source: 只改以下兩個參數\n"),_("ul",[_("li",[t._v("IP Address 改成 0.0.0.0，代表來自任何 IP 位置皆可")]),t._v(" "),_("li",[t._v("Port 改成 12345，表示從 Port 12345 接收資料。")])])]),t._v(" "),_("li",[t._v("QT GUI Sink: 全部用預設值。")]),t._v(" "),_("li",[t._v("Audio Sink: 全部用預設值。")])]),t._v(" "),_("p",[t._v("注意 UDP Source 的參數，表示會接收從任何網址傳到本機的 UDP Port 12345 的資料。另外 QT GUI Sink 可用來觀察接收到的訊號。")]),t._v(" "),_("p",[t._v("接好之後，將檔案存檔，產出模型並執行（先執行傳送端，再執行接收端），應該會看到與傳送端相同的弦波圖形，另外也會聽到音頻的聲音。")]),t._v(" "),_("p",[t._v("如果執行的時候，發現左下的視窗出現 aUaUaU... 的訊息，同時音頻有間斷的現象，表示資料無法 100% 即時傳送。在這種情況下，可以試著 Disable 掉傳送端或接收端的 QT GUI Sink，看情況是否有所改善。如果還是不行的話，就把接收端的 Audio Sink 拿掉，只使用 QT GUI Sink 觀察波形就好。")]),t._v(" "),_("br"),t._v(" "),_("exercise"),t._v(" "),_("ol",[_("li",[t._v("試著加上一個 Range 元件，讓傳送的訊號頻率可以在執行時進行調整，並觀察接收端是否會跟著進行改變。")]),t._v(" "),_("li",[t._v("試著修改傳送端的 UDP Sink 參數，把資料傳到另一台電腦。另外把接收端搬到另一台電腦上執行，看是否可以正確接收到資料。")]),t._v(" "),_("li",[t._v("如果兩台電腦的資料傳送成功，試著加入第三台電腦，看能否正確傳送資料。（此時中間的電腦接收到第一台電腦的資料之後，其輸出應該為 UDP Sink，也就是用來轉傳到第三台電腦的意思。）這個方式可以不斷擴充，可加入更多的電腦。")])])],1)}),[],!1,null,null,null);i.default=s.exports}}]);